#include <linux/init.h>
#include <linux/threads.h>
#include <asm/setup.h>
#include <asm/csky.h>
#include <asm/page.h>
#include <asm/entry.h>
/*
 *	Board setup info.
 */
.data

_ramvec:
.long	0

bootloader_tags:
.long	0

.align 12
swapper_pg_dir:
.fill	4096
empty_bad_page:
.fill	4096
empty_bad_page_table:
.fill	4096
invalid_pte_table:
.fill	4096

.align 10
virtual_vec_base:
.fill	128, 4

__HEAD
/*
 *	This is the codes first entry point. This is where it all
 *	begins...
 */
#define PHY_MEM_BASE    0x10000000     /* Memory base at address 0 */
        .section .start,"ax"
        .align
_stext:
_start:
	.rept   8
	mov     r0, r0
	.endr
	mtcr r2,ss2
	mtcr r3,ss3
no_tag_table:
        /*
         * Init psr value, enable exception, disable interrupt and fast interrupt.
         * psr = 0x80000100
         */
        bgeni   r1, 31
        bseti   r1, 8
        mtcr    r1, psr
//cache_on:
        /*
         *      Enable internal cache.
         */
#ifdef CONFIG_CKCORE_INSTRUCTION_CACHE
        //Invalid instruction cache
        movi    r7, 0x11
        mtcr    r7, cr17
        //Enable instruction cache
        mfcr    r7, cr18
        bseti   r7, 2
        mtcr    r7, cr18
#endif

#ifdef CONFIG_CKCORE_DATA_CACHE
        //Invalid Data cache
        movi    r7, 0x12
        mtcr    r7, cr17
        //Enable data cache
        mfcr    r7, cr18
        bseti   r7, 3
        mtcr    r7, cr18
#endif

/*
 * Setup the initial page tables.  We only setup the barest
 * amount which are required to get the kernel running, which
 * generally means mapping in the kernel code.
 *
 * We only map in 2 * PAGE_SIZE of RAM, which should be sufficient in
 * all cases.
 *
 * r5, r6 = physical address of start RAM
 * r7 = Virtual address
 */
__create_page_table:
        /*
         * Create identity mapping for first MB of kernel to
         * cater for the MMU enable.  This identity mapping
         * will be removed by paging_init()
         */

        lrw     r8, PHY_MEM_BASE  //get physical address of start RAM
        movi    r2, 0
        movi    r5, 0x00000016 //C = 010, D = 1, V = 1, G = 0, pfn = 0x0
        movi    r6, 0x00000056 //C = 010, D = 1, V = 1, G = 0, pfn = 0x1
        movi    r7, 0x00000000 //VPN2 = 0x0, ASID = 0
        bmaski  r9, 13
        andn    r8, r9
        or      r7, r8          // VPN2 is bit 31-12 of phy addr
        lsri    r8, 6           // get bit 31-12 of phy addr
        or      r5, r8              //pfn
        or      r6, r8          //pfn

        SET_CP_MMU

        //invalid mmu jtlb(ASID)
        bgeni   r1, 27
        WR_MCIR r1

        WR_MPR  r2              // page mask = 4k
        WR_MEL0 r5
        WR_MEL1 r6
        WR_MEH  r7

        //Initial TLB
        bgeni   r2, 28              //TLBWR
        WR_MCIR r2
		/*enable MMU
		mfcr    r7, cr18
		bseti   r7, 0
		bclri   r7, 1
		mtcr    r7, cr18
		*/
        /*
         * Enable predict for jump, return stack, and cache write back.
         */
        mfcr    r7 , cr18
        bseti   r7 , 11                 /* BTB */
        bseti   r7 , 6                  /* branch prediction */
        bseti   r7 , 5                  /* forecast jump  for ck610  */
        bseti   r7 , 4                  /* write back for ck610  */
        mtcr    r7 , cr18

	/*
	 *	Setup initial vector base table for interrupts and exceptions
	 */
__create_vector_table:
	lrw     r1, virtual_vec_base    /* Load pre-defined vbr */
	lrw     r2, _ramvec             /* Load address of _ramvec */
	stw     r1, (r2)                /* Write vbr setting to it */
	mtcr    r1, vbr                 /* Set vbr register with physical address */

	//adr		r0, LC0
	lrw		r1,LC0
	lrw	    r4,PHY_MEM_BASE
	lrw	    r5,_start
	lrw	    r6,_got_start
	lrw	    r7,_got_end
	lrw	    r13,user_stack+4096
	mov 	r0,r1
	cmpne r0,r1
	sub	r0, r0, r1		// calculate the delta offset
						// if delta is zero, we are
	bf	not_relocated		// running at the address we
						// were linked at.

		/*
		 * We're running at a different address.  We need to fix
		 * up various pointers:
		 *   r5 - zImage base address
		 *   r6 - GOT start
		 *   r7 - GOT end
		 *"/"
	add r5, r0
	add r6, r0
	add r7, r0

		"/"*
		 * Relocate entries in the GOT table.  We only relocate
		 * the entries that are outside the (relocated) BSS region.
		 *"/"
1:	ldm	r1, (r6)		// relocate entries in the GOT
	cmp	r1, r2			// entry < bss_start ||
	cmphs	r3, r1			// _end < entry
	addlo	r1, r0		// table.  This fixes up the
	stw	r1, (r6,0)		// C references.
	addi 	r6,4
	cmplt	r6, r7
	bt	1b
	*/

not_relocated:
/*
	 *	Zero the bss region.
	 */
	lrw	    r1, _sbss               /* Get start of bss */
	lrw	    r2, _ebss               /* Get end of bss */
	subu    r2, r1                  /* Calculate size of bss */
	lsri    r2, 2                   /* Size of whole words */

	movi    r3, 0                   /* Set zero value to write */
       
1:
	stw     r3, (r1)                /* Zero next word */
	addi    r1, 4                   /* Increase bss pointer */
	decne   r2                      /* Decrease counter */
	bt      1b                      /* Repeat for all bss */


        lrw         r4, zreladdr
        lrw         r5,_start
        lrw         r13,user_stack+4096
	

	mov	r1, r13			// ma1loc space above stack
	lrw r3, 0x10000
	mov	r2, r3
	add	r2, r13	// 64k max


/*
 * Check to see if we will overwrite ourselves.
 *   r4 = final kernel address
 *   r5 = start of this image
 *   r2 = end of malloc space (and therefore this image)
 * We basically want:
 *   r4 >= r2 -> OK
 *   r4 + image length <= r5 -> OK
 */

	cmphs	r4, r2
	bt	wont_overwrite
	mov r3,	r13
	sub	r3, r5		// > compressed kernel size
	mov r0, r4
	lsli r3,2
	add	r0,r3// allow for 4x expansion
	cmplt	r0, r5
	bt	wont_overwrite

	mov	r0, r2			// decompress after malloc space
	mov	r3, r1
	mov	r11, r2
	mov	r10,r4
	mov	r4, r2
	mov	r5,r8
	jsri	decompress_kernel
	
	mov	r4,r10
	lrw r10, 255
	add	r2, r10	// alignment + stack
	lrw r10, 0xFFFFFFFF
	lrw r14,127
	subu r10,r14
	and r2,r10
	mov r5,r11
	mov r0,r2
	mov r2,r11
/*
 * r0     = decompressed kernel length
 * r1-r3  = unused
 * r4     = kernel execution address
 * r5     = decompressed kernel start
 * r6     = processor ID
 * r7     = architecture ID
 * r8     = atags pointer
 * r9-r12,r14 = corrupted
 */
 		mov r1, r5
		add	r1, r0		// end of decompressed kernel
		lrw	r2, reloc_start
		lrw	r3, reloc_end
1:		ldw	r10,(r2,0)	// copy relocation code
		stw	r10,(r1,0)
		addi	r2,4
		addi	r1,4
		cmplt	r2, r3
		bt	1b
		mov	r14, r1
		lrw	r10,128
		add	r13, r10		// relocate the stack
		//jsri	cache_clean_flush
		mov	r2,r5
		add	r2,r0
		jmp	r2
wont_overwrite:	
		mov	r2, r4
		mov	r3,r1
		mov	r5, r8
		jsri	decompress_kernel
		mov	r0,r2	
		jmpi	call_kernel

		.align	2
		.type	LC0, object
LC0:		.long	LC0			// r1
		.long	_sbss		// r2
		.long	_ebss			// r3
		.long	zreladdr		// r4
		.long	_start			// r5
		.long	_got_start		// r6
		.long	_got_end		// r7
		.long	user_stack+4096		// r14
LC1:		.long	reloc_end - reloc_start
		.size	LC0, . - LC0

		/*
 * All code following this line is relocatable.  It is relocated by
 * the above code to the end of the decompressed kernel image and
 * executed there.  During this time, we have no stacks.
 *
 * r0     = decompressed kernel length
 * r1-r3  = unused
 * r4     = kernel execution address
 * r5     = decompressed kernel start
 * r6     = processor ID
 * r7     = architecture ID
 * r8     = atags pointer
 * r9-r12,r14 = corrupted
 */
               .align  5
reloc_start:
                mov r3, r5
                add     r3, r0
                bgeni	r10, 7
                sub     r3, r10         // do not copy the stack
                mov     r1, r4
1:
                ldw     r10, (r5,0)    // relocate kernel
                stw     r10, (r1,0)
                addi    r5,4
                addi    r1,4
                cmplt   r5, r3
                bt      1b
                mov     r13, r1
                bgeni	r10, 7
                add     r13, r10         // relocate the stack
				//jsri	cache_clean_flush
call_kernel:
	//Invalid instruction cache
	movi    r10, 0x11
	mtcr    r10, cr17
	//Invalid Data cache
	movi    r10, 0x12
	mtcr    r10, cr17
	bgeni	r0, 0			// must be zero
	mfcr	r2, ss2			// restore atags pointer
	mfcr	r3, ss3
	jmp r4			// call kernel
reloc_end:
		.align
		.section ".stack", "w"
user_stack:	.space	4096
1:
	br      1b				        /* Should never get here */

